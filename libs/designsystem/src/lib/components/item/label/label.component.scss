@use '~@kirbydesign/core/src/scss/utils';
@use '../item.utils';
@use '../../section-header/section-header.utils';

:host {
  // @include utils.media('>=medium') {
  // &.horizontal {
  //   ion-label {
  //     display: grid;
  //     grid-template-columns: 2fr 1fr;
  //     column-gap: 10px;
  //     align-items: baseline;
  //   }
  // }

  // IDEA:
  //  * Use input properties to bind class selectors
  //  * Style different layouts controlled by those classes
  //  * Optional: Use with or without existing direction property?
  //  * Maybe context dependant? Use input properties on kirby-list or kirby-list-item?

  // ADDITIONAL IDEAS:
  //  * Expose custom properties that allows for control of column count and widths
  //  * Can this be achieved without introducing kirby-item-responsive?
  //    - Consumer projects just add their own container and style it
  //    - Can we allow control of inner layout (ion-label) using just custom properties?
  //  * Consider not using kirby-label - instead use some layout containers that can live in item-responsive...?
  //    - Update: kirby-label appears to be a central part of this solution, so a lot is lost without it
  //  * Would a Flexbox-based solution with breakpoints$ be better?

  :host-context(kirby-item-responsive) {
    ion-label {
      display: grid;
      column-gap: 1rem;
      align-items: baseline;
      grid-template-columns: auto;

      @include utils.media('>=medium') {
        // TODO: Allow for different number of columns
        grid-template-columns: var(--kirby-item-inner-columns, 1fr 1fr);
      }
    }

    &[slot='end'] {
      ion-label {
        justify-items: end;

        @include utils.media('>=medium') {
          grid-template-columns: var(--kirby-item-inner-columns-end, 1fr 1fr);
        }
      }
    }
  }

  // &.horizontal ion-label {
  //   display: flex;
  //   flex-direction: row;
  //   justify-content: space-between;
  //   align-items: center;

  //   @include utils.slotted(':not(:first-child)') {
  //     margin-left: utils.size('xs');
  //   }
  // }
}

:host-context(kirby-item) ion-label {
  @include item.item-typography;
}

:host-context(kirby-section-header) ion-label {
  @include section-header.typography;
}

:host([slot='end']) ion-label {
  @include utils.slotted(data, '[detail]') {
    margin-inline-start: utils.size('s');
  }
}

:host-context(kirby-item.selected) ion-label {
  @include utils.slotted(h1, h2, h3, h4, h5, h6, 'p:not([detail])', 'data:not([detail])') {
    font-weight: utils.font-weight('bold');
  }
}
